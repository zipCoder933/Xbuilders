/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.xbuilders.engine.mesh;

import com.xbuilders.engine.gameScene.GameScene;
import com.xbuilders.engine.items.BlockList;
import com.xbuilders.engine.items.block.Block;
import com.xbuilders.engine.utils.math.MathUtils;
import com.xbuilders.engine.world.chunk.Chunk;
import com.xbuilders.engine.world.chunk.ChunkVoxels;
import com.xbuilders.engine.world.wcc.WCCi;

import java.nio.IntBuffer;
import java.util.HashMap;

import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector3i;
import org.lwjgl.system.MemoryStack;

/**
 * @author zipCoder933
 */
public class GreedyMesher {

    /*
     * These are just constants to keep track of which face we're dealing with - their actual
     * values are unimportantly - only that they're constant.
     */
    private static final int NEG_X = 0;
    private static final int POS_X = 1;

    private static final int NEG_Z = 2;
    private static final int POS_Z = 3;

    private static final int POS_Y = 4;
    private static final int NEG_Y = 5;

    ChunkVoxels chunkVoxels;
    final int[] dims;
    HashMap<Short, Block> blockMap;

    public GreedyMesher(ChunkVoxels voxels, HashMap<Short, Block> blockMap) {
        this.chunkVoxels = voxels;
        this.blockMap = blockMap;
        dims = new int[]{voxels.size.x, voxels.size.y, voxels.size.z};
    }

    /**
     * Check if 2 voxel faces are the same
     */
    private boolean equals(int val1, int val2) {
        return val1 == val2;
    }


    public void compute(BufferSet opaqueBuffers, BufferSet transparentBuffers,
                        BufferSet LOD_buffers,
                        Vector3i chunkPosition,
                        MemoryStack stack,
                        int lodLevel) {

        /**
         * These are just working variables for the algorithm - almost all taken
         * directly from Mikola Lysenko's javascript implementation.
         */
        int i, j, k, l, w, h, u, v, n, side = 0;

        final int[] x = new int[]{0, 0, 0};
        final int[] q = new int[]{0, 0, 0};
        final int[] du = new int[]{0, 0, 0};
        final int[] dv = new int[]{0, 0, 0};


        /**
         * These are just working variables to hold two faces during comparison.
         */
        Vector3i voxelPos = new Vector3i(stack.mallocInt(3));
        short thisPlaneVoxel, nextPlaneVoxel;
        byte sun, sun1;
        Block block, block1;

        for (boolean backFace = true, b = false; b != backFace; backFace = backFace && b, b = !b) {
            for (int d = 0; d < 3; d++) {

                u = (d + 1) % 3;//v and u are the perpendicular dimensions to d
                v = (d + 2) % 3;

                x[0] = 0;//X is the position vector, X[d] advances forward in the given dimension
                x[1] = 0;
                x[2] = 0;

                q[0] = 0;//Q is the dimension vector, for example, if d=1, q = [0,1,0]
                q[1] = 0;
                q[2] = 0;
                q[d] = 1;

                Chunk forwardChunk = GameScene.world.getChunk(new Vector3i(chunkPosition.x + q[0], chunkPosition.y + q[1], chunkPosition.z + q[2]));
                Chunk backChunk = GameScene.world.getChunk(new Vector3i(chunkPosition.x - q[0], chunkPosition.y - q[1], chunkPosition.z - q[2]));

                if (d == 0) {
                    side = backFace ? NEG_X : POS_X;
                } else if (d == 1) {
                    side = backFace ? NEG_Y : POS_Y;
                } else if (d == 2) {
                    side = backFace ? NEG_Z : POS_Z;
                }

                //We create the mask here (We MUST use it this way IF the chunk dimensions are not cubic)
                final IntBuffer mask = stack.mallocInt(dims[u] * dims[v]);
                final IntBuffer lodMask = stack.mallocInt((dims[u] / lodLevel) * (dims[v] / lodLevel));

                /*
                 * We move through the d from front to back
                 */
                int min = 0;//-1 (We changed this to 0, so chunks dont overlap. The dim starts at 0 and ends up covering the next chunks faces)
                int max = dims[d];

                //If the chunk is not terrainLoaded, dont draw the side that it is on
                if (forwardChunk == null || forwardChunk.generationStatus < Chunk.GEN_TERRAIN_LOADED) {
                    max = dims[d] - 1;
                }
                if (backChunk == null || backChunk.generationStatus < Chunk.GEN_TERRAIN_LOADED) {
                    min = 0;
                }

                for (x[d] = min; x[d] < max; ) {
                    /**
                     * -------------------------------------------------------------------
                     * We compute the mask
                     * -------------------------------------------------------------------
                     */
                    n = 0;

                    for (x[v] = 0; x[v] < dims[v]; x[v]++) {//v and u are the perpendicular dimensions to d, we sweep across the plane of V and U
                        for (x[u] = 0; x[u] < dims[u]; x[u]++) {
                            //<editor-fold defaultstate="collapsed" desc="Retrieve 2 voxel faces">
                            //Here we retrieve two voxel faces for comparison.
                            //thisPlaneVoxel literaly faces forward, while nextPlaneVoxel faces backward
                            if (x[d] >= 0) { //Calculate the voxel of THIS plane
                                thisPlaneVoxel = chunkVoxels.getBlock(x[0], x[1], x[2]);
                            } else {//If we are out of bounds for this chunk:
                                if (backChunk == null) {
                                    thisPlaneVoxel = 0;
                                } else {
                                    voxelPos.set(
                                            MathUtils.positiveMod(x[0], Chunk.WIDTH),
                                            MathUtils.positiveMod(x[1], Chunk.WIDTH),
                                            MathUtils.positiveMod(x[2], Chunk.WIDTH));
                                    thisPlaneVoxel = backChunk.data.getBlock(voxelPos.x, voxelPos.y, voxelPos.z);
                                }
                            }

                            if (x[d] < dims[d] - 1) { //calculate the voxel of the NEXT plane
                                voxelPos.set(x[0] + q[0], x[1] + q[1], x[2] + q[2]);
                                nextPlaneVoxel = chunkVoxels.getBlock(voxelPos.x, voxelPos.y, voxelPos.z);
                            } else {//If we are out of bounds for this chunk:
                                if (forwardChunk == null) {
                                    nextPlaneVoxel = 0;
                                } else {
                                    voxelPos.set(
                                            MathUtils.positiveMod(x[0] + q[0], Chunk.WIDTH),
                                            MathUtils.positiveMod(x[1] + q[1], Chunk.WIDTH),
                                            MathUtils.positiveMod(x[2] + q[2], Chunk.WIDTH));
                                    nextPlaneVoxel = forwardChunk.data.getBlock(voxelPos.x, voxelPos.y, voxelPos.z);
                                }
                            }
//</editor-fold>

                            block = blockMap.get((short) thisPlaneVoxel);
                            block1 = blockMap.get((short) nextPlaneVoxel);

                            if (block.isAir() || block.type != BlockList.DEFAULT_BLOCK_TYPE_ID) {
                                thisPlaneVoxel = 0;
                            }
                            if (block1.isAir() || block1.type != BlockList.DEFAULT_BLOCK_TYPE_ID) {
                                nextPlaneVoxel = 0;
                            }

                            sun = retrieveSunForThisPlane(thisPlaneVoxel, backChunk, forwardChunk, block, d, x, q);
                            sun1 = retrieveSunForNextPlane(nextPlaneVoxel, backChunk, forwardChunk, block1, d, x, q);

                            int thisPlanePacked = (thisPlaneVoxel << 8) | (sun & 0xFF);
                            int nextPlanePacked = (nextPlaneVoxel << 8) | (sun1 & 0xFF);

                            mask.put(n++, (thisPlaneVoxel == 0 || nextPlaneVoxel == 0) || (block.isOpaque() != block1.isOpaque())//The opaque check is to prevent transparent mesh from overriding opaque one
                                    ? (backFace //add the voxel for either this plane or the next plane depending on our direction
                                    ? nextPlanePacked
                                    : thisPlanePacked)
                                    : 0);
                        }
                    }

                    x[d]++; //move forward

                    /*
                     * Now we generate the mesh for the mask
                     */
                    n = 0;

                    for (j = 0; j < dims[v]; j++) {
                        for (i = 0; i < dims[u]; ) {
                            if (mask.get(n) != 0) {//Make the quad
                                /*
                                 * We compute the w
                                 */
                                for (w = 1; i + w < dims[u] && mask.get(n + w) != 0 && equals(mask.get(n + w), mask.get(n)); w++) {
                                }

                                /*
                                 * Then we compute h
                                 */
                                boolean done = false;

                                for (h = 1; j + h < dims[v]; h++) {
                                    for (k = 0; k < w; k++) {
                                        if (mask.get(n + k + h * dims[u]) == 0 || mask.get(n + k + h * dims[u]) != mask.get(n)) {
                                            done = true;
                                            break;
                                        }
                                    }
                                    if (done) {
                                        break;
                                    }
                                }

                                /*
                                 * Here we check the "transparent" attribute in the VoxelFace class to ensure that we don't mesh
                                 * any culled faces.
                                 */
                                if (mask.get(n) != 0) {
                                    /*
                                     * Add quad
                                     */
                                    x[u] = i;
                                    x[v] = j;

                                    du[0] = 0;
                                    du[1] = 0;
                                    du[2] = 0;
                                    du[u] = w;

                                    dv[0] = 0;
                                    dv[1] = 0;
                                    dv[2] = 0;
                                    dv[v] = h;

                                    /*
                                     * And here we call the quad function in order to render a merged quad in the scene.
                                     *
                                     * We pass mask[n] to the function, which is an instance of the VoxelFace class containing
                                     * all the attributes of the face - which allows for variables to be passed to shaders - for
                                     * example lighting values used to create ambient occlusion.
                                     */
                                    Mesher_makeQuad(opaqueBuffers, transparentBuffers,
                                            x, du, dv, w, h, mask.get(n),
                                            backFace, d, side, stack);

                                    Mesher_makeLODQuad(LOD_buffers, x, du, dv, w, h, mask.get(n), backFace, d, side, stack);
                                }

                                /*
                                 * We zero out the mask
                                 */
                                for (l = 0; l < h; ++l) {
                                    for (k = 0; k < w; ++k) {
                                        mask.put(n + k + l * dims[u], 0);
                                    }
                                }

                                /*
                                 * And then finally increment the counters and continue
                                 */
                                i += w;
                                n += w;
                            } else {
                                i++;
                                n++;
                            }
                        }
                    }
                }
            }
        }
    }


    final int[] indexes1 = {2, 0, 1, 1, 3, 2};
    final int[] indexes2 = {2, 3, 1, 1, 0, 2};

    final Vector3f[] vertices = {new Vector3f(), new Vector3f(), new Vector3f(), new Vector3f()};
    final Vector2f[] uvs = {new Vector2f(), new Vector2f(), new Vector2f(), new Vector2f()};
    final Vector3i[] completeVertex = {new Vector3i(), new Vector3i(), new Vector3i(), new Vector3i()};


    protected void Mesher_makeLODQuad(BufferSet lodBuffer,
                                      int x[], int du[], int dv[], final int w, final int h,
                                      final int voxel, final boolean backFace, final int d, final int side,
                                      MemoryStack stack) {
        short blockVal = (short) ((voxel >> 8) & 0xFFFF);
        byte sun = (byte) (voxel & 0xFF);
        Block block = blockMap.get(blockVal);
        if (block != null && block.texture != null) {
            int[] indexes = backFace ? indexes1 : indexes2;
            int texture;
            vertices[0].set(x[0], x[1], x[2]);
            vertices[1].set(x[0] + dv[0], x[1] + dv[1], x[2] + dv[2]);
            vertices[2].set(x[0] + du[0], x[1] + du[1], x[2] + du[2]);
            vertices[3].set(x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2]);

            switch (d) {
                case 0 -> {
                    if (backFace) {
                        texture = block.texture.getNEG_X();
                    } else {
                        texture = block.texture.getPOS_X();
                    }

                    // Z=180 flip
                    uvs[3].set(0, w);
                    uvs[2].set(h, w);
                    uvs[1].set(0, 0);
                    uvs[0].set(h, 0);
                }
                case 1 -> {
                    if (backFace) {
                        texture = block.texture.getNEG_Y();
                    } else {
                        texture = block.texture.getPOS_Y();
                    }

                    uvs[0].set(0, w);
                    uvs[1].set(h, w);
                    uvs[2].set(0, 0);
                    uvs[3].set(h, 0);
                }
                default -> {
                    if (backFace) {
                        texture = block.texture.getNEG_Z();
                    } else {
                        texture = block.texture.getPOS_Z();
                    }

                    // X=90 flip
                    uvs[1].set(0, h);
                    uvs[3].set(w, h);
                    uvs[0].set(0, 0);
                    uvs[2].set(w, 0);
                }
            }

            byte normalAndAO = (byte) side;

            for (int i = 0; i < 4; i++) {
                Vector3f vertex = vertices[i];
                completeVertex[i].set(
                        VertexPackingUtils.packFirstInt(vertex.x, vertex.y, normalAndAO),
                        VertexPackingUtils.packSecondInt(vertex.z, uvs[i].x, uvs[i].y),
                        VertexPackingUtils.packThirdInt(texture, sun, 0));
            }
            for (int i = 0; i < indexes.length; i++) {
                int j = indexes[i];
                lodBuffer.vertex(
                        completeVertex[j].x,
                        completeVertex[j].y,
                        completeVertex[j].z);
            }
        }
    }


    // d: 0=X,1=Y,2=Z
    protected void Mesher_makeQuad(BufferSet buffers, BufferSet transBuffers,
                                   int x[], int du[], int dv[], final int w, final int h,
                                   final int voxel, final boolean backFace, final int d, final int side,
                                   MemoryStack stack) {

        short blockVal = (short) ((voxel >> 8) & 0xFFFF);
        byte sun = (byte) (voxel & 0xFF);

        Block block = blockMap.get(blockVal);

        if (block != null && block.texture != null) {
            int[] indexes = backFace ? indexes1 : indexes2;
            int texture;

//<editor-fold defaultstate="collapsed" desc="nublada quad method">
//        int[] vertices = new int[8];
//        vertices[0] = packCoords(x[0], x[1], x[2]);
//        vertices[2] = packCoords(x[0] + dv[0], x[1] + dv[1], x[2] + dv[2]);
//        vertices[4] = packCoords(x[0] + du[0], x[1] + du[1], x[2] + du[2]);
//        vertices[6] = packCoords(x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2]);
//        if (d == 2) {
//            if (!backFace) {
//                vertices[1] = packCoords(0, h, 0);
//                vertices[3] = packCoords(0, 0, 0);
//                vertices[5] = packCoords(w, h, 0);
//                vertices[7] = packCoords(w, 0, 0);
//            } else {
//                vertices[1] = packCoords(w, h, 0);
//                vertices[3] = packCoords(w, 0, 0);
//                vertices[5] = packCoords(0, h, 0);
//                vertices[7] = packCoords(0, 0, 0);
//            }
//        } else if (d == 0) {
//            if (backFace) {
//                vertices[1] = packCoords(0, w, 0);
//                vertices[3] = packCoords(h, w, 0);
//                vertices[5] = packCoords(0, 0, 0);
//                vertices[7] = packCoords(h, 0, 0);
//            } else {
//                vertices[1] = packCoords(h, w, 0);
//                vertices[3] = packCoords(0, w, 0);
//                vertices[5] = packCoords(h, 0, 0);
//                vertices[7] = packCoords(0, 0, 0);
//            }
//        } else {
//            if (!backFace) {
//                vertices[1] = packCoords(0, 0, 0);
//                vertices[3] = packCoords(h, 0, 0);
//                vertices[5] = packCoords(0, w, 0);
//                vertices[7] = packCoords(h, w, 0);
//            } else {
//                vertices[1] = packCoords(h, 0, 0);
//                vertices[3] = packCoords(0, 0, 0);
//                vertices[5] = packCoords(h, w, 0);
//                vertices[7] = packCoords(0, w, 0);
//            }
//        }
//        verts.add((float) vertices[0]);
//        verts.add((float) vertices[1]);
//        verts.add((float) vertices[2]);
//        verts.add((float) vertices[3]);
//        verts.add((float) vertices[4]);
//        verts.add((float) vertices[5]);
//        verts.add((float) vertices[6]);
//        verts.add((float) vertices[7]);
//</editor-fold>
//The ONLY difference betweent this method and nublada is that nublada uses packed single integer coordinates, and that uvs and vertex positions are combined
            vertices[0].set(x[0], x[1], x[2]);
            vertices[1].set(x[0] + dv[0], x[1] + dv[1], x[2] + dv[2]);
            vertices[2].set(x[0] + du[0], x[1] + du[1], x[2] + du[2]);
            vertices[3].set(x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2]);

            switch (d) {
                case 0 -> {
                    if (backFace) {
                        texture = block.texture.getNEG_X();
                    } else {
                        texture = block.texture.getPOS_X();
                    }

                    // Z=180 flip
                    uvs[3].set(0, w);
                    uvs[2].set(h, w);
                    uvs[1].set(0, 0);
                    uvs[0].set(h, 0);
                }
                case 1 -> {
                    if (backFace) {
                        texture = block.texture.getNEG_Y();
                    } else {
                        texture = block.texture.getPOS_Y();
                    }

                    uvs[0].set(0, w);
                    uvs[1].set(h, w);
                    uvs[2].set(0, 0);
                    uvs[3].set(h, 0);
                }
                default -> {
                    if (backFace) {
                        texture = block.texture.getNEG_Z();
                    } else {
                        texture = block.texture.getPOS_Z();
                    }

                    // X=90 flip
                    uvs[1].set(0, h);
                    uvs[3].set(w, h);
                    uvs[0].set(0, 0);
                    uvs[2].set(w, 0);
                }
            }

            byte normalAndAO = (byte) side;

            for (int i = 0; i < 4; i++) {
                Vector3f vertex = vertices[i];
                completeVertex[i].set(
                        VertexPackingUtils.packFirstInt(vertex.x, vertex.y, normalAndAO),
                        VertexPackingUtils.packSecondInt(vertex.z, uvs[i].x, uvs[i].y),
                        VertexPackingUtils.packThirdInt(texture, sun, 0));
            }

            if (block.isOpaque()) {
                for (int i = 0; i < indexes.length; i++) {
                    int j = indexes[i];
                    buffers.vertex(
                            completeVertex[j].x,
                            completeVertex[j].y,
                            completeVertex[j].z);
                }
            } else {
                for (int i = 0; i < indexes.length; i++) {
                    int j = indexes[i];
                    transBuffers.vertex(
                            completeVertex[j].x,
                            completeVertex[j].y,
                            completeVertex[j].z);
                }
            }
        }
    }

    private byte retrieveSunForThisPlane(short thisPlaneVoxel, Chunk backChunk, Chunk forwardChunk, Block block, int d, int[] x, int[] q) {
//        //This plane = top face, +X face and +Z face (x and z assuming you are starting from the center of the chunk and moving outwards)
        if (thisPlaneVoxel != 0) {
            if (block.isTransparent()) {
                if (x[d] >= 0) {
                    return chunkVoxels.getSun(x[0], x[1], x[2]);
                } else if (backChunk != null) {
                    return backChunk.data.getSun(
                            MathUtils.positiveMod(x[0], Chunk.WIDTH),
                            MathUtils.positiveMod(x[1], Chunk.WIDTH),
                            MathUtils.positiveMod(x[2], Chunk.WIDTH));
                }
            } else {
                if (x[d] + 1 < dims[d]) {
                    return chunkVoxels.getSun(x[0] + q[0], x[1] + q[1], x[2] + q[2]);
                } else if (forwardChunk != null) {
                    byte sun = forwardChunk.data.getSun(
                            MathUtils.positiveMod(x[0] + q[0], Chunk.WIDTH),
                            MathUtils.positiveMod(x[1] + q[1], Chunk.WIDTH),
                            MathUtils.positiveMod(x[2] + q[2], Chunk.WIDTH));
                    return sun;
                }
            }
        }
        return 0;
    }

    private byte retrieveSunForNextPlane(short nextPlaneVoxel, Chunk backChunk, Chunk forwardChunk, Block block1, int d, int[] x, int[] q) {
        //next plane = bottom face, -X face and -Z face (x and z assuming you are starting from the center of the chunk and moving outwards)
        if (nextPlaneVoxel != 0) {
            if (block1.isTransparent()) {
                if (x[d] + 1 < dims[d]) { //we changed <dims[d]-1 to dims[d]. Investigate if we need to switch this in the voxel plane as well
                    return chunkVoxels.getSun(x[0] + q[0], x[1] + q[1], x[2] + q[2]);
                } else if (forwardChunk != null) {
                    return forwardChunk.data.getSun(
                            MathUtils.positiveMod(x[0] + q[0], Chunk.WIDTH),
                            MathUtils.positiveMod(x[1] + q[1], Chunk.WIDTH),
                            MathUtils.positiveMod(x[2] + q[2], Chunk.WIDTH));
                }
            } else {
                if (x[d] >= 0) {
                    return chunkVoxels.getSun(x[0], x[1], x[2]);
                } else if (backChunk != null) {
                    return backChunk.data.getSun(
                            MathUtils.positiveMod(x[0], Chunk.WIDTH),
                            MathUtils.positiveMod(x[1], Chunk.WIDTH),
                            MathUtils.positiveMod(x[2], Chunk.WIDTH));
                }
            }
        }
        return 0;
    }
}
