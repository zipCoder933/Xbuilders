{\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\fswiss\fprq2\fcharset0 Calibri;}{\f2\fswiss\fprq2\fcharset0 Calibri Light;}{\f3\fmodern\fprq1\fcharset0 Consolas;}{\f4\fmodern\fprq1\fcharset0 Courier New;}{\f5\fnil\fcharset0 Calibri;}{\f6\fnil\fcharset2 Symbol;}}
{\colortbl ;\red118\green118\blue118;\red47\green84\blue150;\red255\green255\blue0;\red192\green0\blue0;\red30\green78\blue121;\red46\green117\blue181;\red0\green176\blue80;}
{\*\listtable 
{\list\listhybrid
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}\listid1 }
{\list\listhybrid
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}\listid2 }
{\list\listhybrid
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}
{\listlevel\levelnfc23\leveljc0\levelstartat1{\leveltext\'01\'B7;}{\levelnumbers;}\f6\jclisttab\tx360}\listid3 }}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\widctlpar\s1\sb100\sa100\kerning36\b\f0\fs48\lang1033 Nublada\par

\pard\widctlpar\cf1\kerning0\b0\f1\fs20 Thursday, November 2, 2023\par
8:36 AM\par

\pard\keep\keepn\widctlpar\s2\sb40\sl252\slmult1\cf2\kerning2\f2\fs26 GUI Rendering\par

\pard\widctlpar\cf0\kerning0\f1\fs21 Nublada renders their crosshair like so \highlight3 (note that these are legacy draw calls, so if they are not supported I am ok with that)\highlight0 :\par
\~\par
\highlight4     private void renderCrosshair() \{\highlight0\par
\highlight4         glUseProgram(0);\highlight0\par
\highlight4         glColor3f(1.0f, 1.0f, 1.0f);\highlight0\par
\highlight4         glLineWidth(2.0f);\highlight0\par
\~\par
\highlight4         glBegin(GL_LINES);\highlight0\par
\highlight4         glVertex2f(-0.1f, 0.0f); // Horizontal line (left)\highlight0\par
\highlight4         glVertex2f(0.1f, 0.0f); // Horizontal line (right)\highlight0\par
\highlight4         glVertex2f(0.0f, -0.1f); // Vertical line (bottom)\highlight0\par
\highlight4         glVertex2f(0.0f, 0.1f); // Vertical line (top)\highlight0\par
\highlight4         glEnd();\highlight0\par
\highlight4     \}\highlight0\par
\~\par
\~\par
The cursor box is also generated likewise:\par
\highlight4    public void drawCube(float x, float y, float z, float size) \{\highlight0\par
\highlight4         // Set the color for the outline (white in this case)\highlight0\par
\highlight4         glColor3f(1.0f, 1.0f, 1.0f);\highlight0\par
\~\par
\highlight4         glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // Set the polygon mode to draw lines\highlight0\par
\~\par
\highlight4         glBegin(GL_QUADS); // Begin drawing quads (faces of the cube)\highlight0\par
\~\par
\highlight4         // Front face\highlight0\par
\highlight4         glVertex3f(x - size / 2, y - size / 2, z - size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y - size / 2, z - size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y + size / 2, z - size / 2);\highlight0\par
\highlight4         glVertex3f(x - size / 2, y + size / 2, z - size / 2);\highlight0\par
\~\par
\highlight4         // Back face\highlight0\par
\highlight4         glVertex3f(x - size / 2, y - size / 2, z + size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y - size / 2, z + size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y + size / 2, z + size / 2);\highlight0\par
\highlight4         glVertex3f(x - size / 2, y + size / 2, z + size / 2);\highlight0\par
\~\par
\highlight4         // Connect faces to create the cube\highlight0\par
\highlight4         glVertex3f(x - size / 2, y - size / 2, z - size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y - size / 2, z - size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y - size / 2, z + size / 2);\highlight0\par
\highlight4         glVertex3f(x - size / 2, y - size / 2, z + size / 2);\highlight0\par
\~\par
\highlight4         glVertex3f(x - size / 2, y + size / 2, z - size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y + size / 2, z - size / 2);\highlight0\par
\highlight4         glVertex3f(x + size / 2, y + size / 2, z + size / 2);\highlight0\par
\highlight4         glVertex3f(x - size / 2, y + size / 2, z + size / 2);\highlight0\par
\~\par
\highlight4         glEnd(); // End drawing\highlight0\par
\~\par
\highlight4         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); // Restore default polygon mode\highlight0\par
\highlight4     \}\highlight0\par
\~\par

\pard\widctlpar\s1\cf5\kerning36\b\fs32\~\par
Chunk generation\par

\pard\keep\keepn\widctlpar\s2\sl252\slmult1\cf6\kerning2\b0\fs28 The addChunk method\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li180\cf0\fs21 Creates a new chunk\par
{\pntext\f6\'B7\tab}Adds it to the HashMap\par
{\pntext\f6\'B7\tab}Sends it to generationService, a ScheduledExecutorService that loads the chunk on a separate thread\par
{\pntext\f6\'B7\tab}Stores the returned future object from the service execution onto a \highlight3 future list\highlight0\par

\pard\widctlpar\kerning0\~\par

\pard\keep\keepn\widctlpar\s2\sl252\slmult1\cf6\kerning2\fs28 worldRenderer.render()\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls1\widctlpar\fi-360\li180\cf0\b\fs21 World.checkGeneratingChunks()\b0\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls1\ilvl1\widctlpar\fi-360\li900 iterates over the \highlight3 future list\highlight0  for all "loaded" chunks.\par
{\listtext\f1 1\tab}If a chunk is loaded\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls1\ilvl2\widctlpar\fi-360\li1620 Chunk.initializeChunk()\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls1\ilvl3\widctlpar\fi-360\li2340 chunk.generateMesh()\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls1\ilvl4\widctlpar\fi-360\li3060 Submits a meshBundle to a meshService, an executor service. The mesh bundle computes the mesh and returns meshFuture. when done, the mesh will be sent to gpu within chunk.prepare on the render thread\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls1\ilvl3\widctlpar\fi-360\li2340 Iterates over the existing neighboring chunks and marks them as not updated\par

\pard\widctlpar\kerning0\~\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls2\widctlpar\fi-360\li180\kerning2\b if the player has moved, \b0\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls2\ilvl1\widctlpar\fi-360\li900 mark needs sorting to true\par

\pard\widctlpar\kerning0\~\par
\~\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li180\kerning2\b Checks if any chunks around the player are non-existent and adds them using world.addChunk()\b0\par

\pard\widctlpar\kerning0\~\par
\~\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\widctlpar\fi-360\li180\kerning2\b If needs sorting\b0\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl1\widctlpar\fi-360\li900 Clear chunksToRender list\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\widctlpar\fi-360\li180\b updateChunksToRenderList()\b0\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl1\widctlpar\fi-360\li900 Iterate over each chunk in the world\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl2\widctlpar\fi-360\li1620 Chunk.prepare()\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl3\widctlpar\fi-360\li2340 If not updated and loaded\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl4\widctlpar\fi-360\li3060 Generate mesh again\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl3\widctlpar\fi-360\li2340 If mesher future is not null and is done\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl4\widctlpar\fi-360\li3060 Send mesh to GPU\par
{\listtext\f1 1\tab}Set mesher future to null\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl2\widctlpar\fi-360\li1620 If the chunk is too far from the view distance, delete it\par
{\listtext\f1 1\tab}Otherwise, If needs sorting, add the chunk to the render list\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\widctlpar\fi-360\li180\b If needs sorting\b0\par

\pard 
{\listtext\f1\u10625?\tab}\jclisttab\tx360\ls3\ilvl1\widctlpar\fi-360\li900 Sort chunksToRender by distance from player\par
{\listtext\f1 1\tab}Set needs sorting to false\par

\pard\widctlpar\kerning0\~\par
\~\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li180\kerning2\b Render all solid meshes\b0\par
{\pntext\f6\'B7\tab}\b Render all transparent meshes\b0\par

\pard\widctlpar\kerning0\~\par
\~\par

\pard\widctlpar\sl280\slmult0\~\par

\pard\widctlpar\cf7\f3\fs20 //= new ScheduledThreadPoolExecutor(1, r -> \{ ... \});: This line creates an instance of ScheduledThreadPoolExecutor.\cf0\f1\fs21\par
\cf7\f3\fs20 //It's a type of ScheduledExecutorService that uses a pool of threads to execute tasks.\cf0\f1\fs21\par
\cf7\f3\fs20 //- 1 specifies that the pool will have one thread. This means it will be capable of executing one task at a time.\cf0\f1\fs21\par
\cf7\f3\fs20 //- r -> \{ ... \} is a lambda expression that provides a ThreadFactory to the executor. It defines how threads are created. In this case,\cf0\f1\fs21\par
\cf7\f3\fs20 //it creates a new thread, sets its name to "Generation Thread", and marks it as a daemon thread (meaning it won't prevent the JVM from exiting).\cf0\f1\fs21\par
\f3\fs20\~ \~ private static final ScheduledExecutorService generationService = new ScheduledThreadPoolExecutor(1, r -> \{\f1\fs21\par
\f3\fs20\~ \~ \~ \~ Thread thread = new Thread(r, "Generation Thread");\f1\fs21\par
\f3\fs20\~ \~ \~ \~ thread.setDaemon(true);\f1\fs21\par
\f3\fs20\~ \~ \~ \~ return thread;\f1\fs21\par
\f3\fs20\~ \~ \});\f1\fs21\par
\f3\fs20\~\f1\fs21\par
\f3\fs20\~\cf7  \~ /**\cf0\f1\fs21\par
\cf7\f3\fs20\~ \~ \~* The service.submit () method does not necessarily run the task on a new thread,\cf0\f1\fs21\par
\cf7\f3\fs20\~ \~ \~* \~but rather on one of the threads in the pool managed by the ScheduledExecutorService.\cf0\f1\fs21\par
\cf7\f3\fs20\~ \~ \~*/\cf0\f1\fs21\par
\f3\fs20\~ \~ Future<Chunk> future = generationService.submit(() -> \{\f1\fs21\par
\f3\fs20\~ \~ \~ \~ //Load the future chunk if it exists\f1\fs21\par
\f3\fs20\~ \~ \~ \~ chunk.loadChunk(this, futureChunk);\f1\fs21\par
\f3\fs20\~ \~ \~ \~ return chunk;\f1\fs21\par
\f3\fs20\~ \~ \});\f1\fs21\par
\~\par
\~\par
\b If a block is set on a chunk that does not exist, it goes to a future chunk.\b0\par
\b If a new chunk is added, or the player moves, change the order at which the chunks are rendered\b0\par

\pard\widctlpar\sa160\sl252\slmult1\kerning2\fs22\par
\par

\pard\widctlpar\kerning0\fs40 Nublada greedy meshing and vertex data\par
\cf1\fs20 Sunday, November 5, 2023\par
9:18 AM\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li720\cf0\f4\fs21 no voxel face class, just block ID\f1\par
{\pntext\f6\'B7\tab}\f4 No computing the side\f1\par
{\pntext\f6\'B7\tab}\f4  Instead of having one big mask, we make a new one for every new dimension\f1\par
{\pntext\f6\'B7\tab}\f4  When retrieving the voxel face, if it is transparent, set it to null\f1\par

\pard\widctlpar\f4\~\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li720 IMPORTANT:\f1\par

\pard\widctlpar\f4 instead of \par
\cf4  mask[n++] = ((voxelFace != null && voxelFace1 != null && voxelFace.equals(voxelFace1)))\par
 ? null : backFace ? voxelFace1 : voxelFace;\par
\cf0\~\par
when adding to the mask, we do (The difference is that there is no block comparison):\par
\cf4 mask[n++] = ((voxelFace == null || voxelFace1 == null)) \par
 ? backFace ? voxelFace1 : voxelFace : null;\par
\cf0\~\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li720 when making the quad, there are 8 verticies instead of 4, making it a vertex and uv list.\f1\par

\pard\widctlpar\li540\f4 * every even vertex is a position, every odd vertex is a uv coordinate\par
* the 3 coordintates of the verticies and uvs are compacted into one\par
* each uv is a 3d coordinate U,V,layer\par

\pard\widctlpar\~\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li720 the "vertex" list (that contains the vertex and uv data every other item) is passed to the GPU as a VBO of size 2, meaning that every 2 values correspond to 1 vector.\f1\par

\pard\widctlpar\f4\~\par
\cf4\fs19     public int loadToVAO(int[] positions, int[] indices, int size) \{\par
        int vao = createVAO();\par
        storeDataInAttributeList(0, size, positions);\par
        bindIndicesBuffer(indices);\par
        return vao;\par
    \}\par
\~\par
\~\par
    private void storeDataInAttributeList(int attributeNumber, int size, float[] data) \{\par
        int vboId = GL30.glGenBuffers();\par
        vboList.add(vboId);\par
        GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboId);\par
        GL30.glBufferData(GL30.GL_ARRAY_BUFFER, data, GL30.GL_STATIC_DRAW);\par
        GL30.glVertexAttribPointer(attributeNumber, size, GL30.GL_FLOAT, false, 0, 0);\par
        GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, 0);\par
    \}\par
\cf0\fs21\~\par
\~\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent360{\pntxtb\'B7}}\widctlpar\fi-360\li720 The compactified coordinates are decompressed in the vertex shader:\f1\par

\pard\widctlpar\f4\~\par
\cf4 in uvec2 vertex;\par
\~\par
    float y = (vertex.x >> 18u) & 0x1FFu;\par
    float x = (vertex.x >> 9u) & 0x1FFu;\par
    float z = (vertex.x) & 0x1FFu;\par
\~\par
    uint yUv = (vertex.y >> 18u) & 0x1FFu;\par
    uint xUv = (vertex.y >> 9u) & 0x1FFu;\par
    uint zUv = (vertex.y) & 0x1FFu;\par

\pard\widctlpar\sa160\sl252\slmult1\cf0\kerning2\f1\fs22\par

\pard\sa200\sl276\slmult1\kerning0\f5\lang9\par
}
 